# AATree
AATree
AA树
前言
   在前面的讲解中我们有看到过复杂但高效的红黑树，也见识过同样高效但是稍微简单一点的确定性跳跃表，虽然相对红黑树，确定性跳跃表已经简单了很多，但是其删除部分其实还是相当复杂的，其编写的代码量同样并没有比红黑树少多少，于是我们不禁要问有没有一个数据结构可达到较好的最坏时间界，但是其编程代码量又相对较小呢？
其实是有的，红黑树的一种变体，BB树，在红黑树性质的基础上加上一个条件，每一个结点最多有一个红色儿子，为了编程的方便，我们在附加一个条件，每个结点中只有右儿子可以是红色的，在这两个条件的限制下，我们可以去除红黑树中许多的恼人情形，这样我们得到的这个数据结构就是AA树

AA树的基础知识
首先我们用level变量替换红黑树中的color变量，我们定义nullNode的高度为0，树叶的高度为1，红色结点的高度与其父节点的高度相同，黑色结点的高度比起父节点的高度低1

水平链接：一个结点的儿子的高度与其本身高度相同，则该结点与其该儿子间构成了一个水平链接

由于我们附加的两个条件与红黑树本身的一些性质，我们知道AA树中的任意结点不能有左水平链接（AA树中只能是右儿子为红色），而且任意结点是不能存在两个连续的右水平链接的（红色结点的子结点不能为红色）只要满足上述的两个条件，构造的该数据结构就是AA树
左水平链接的调整方法：左旋转 skew
连续右水平链接的调整方法：右旋转并提高中间结点的高度 split 
插入
 AA树的插入部分非常简单，就是递归的寻找插入结点的位置，然后自下而上的通过skew和split来维护AA树

删除
AA树的删除部分同样非常简单，还是采用递归自下而上的解决，首先通过递归寻找该删除结点，并寻找其右子树的最小结点，删除时用其右子树的最小结点来替换删除结点，然后删除其右子树的最小结点，如果右子树的最小结点存在右儿子，还需要将其右儿子和其上层结点进行连接，然后我们考虑删除该结点后AA树的修复操作，只有我们删除一个结点后邻层结点中出现高度相差2的情况下才需要修复，方法是把高层结点结点高度都降低1，此时在一层最多会出现6个结点，所有最多会存在3个左水平链接或者2个连续的右水平链接，我们通过3次skew和2次split便可以解决所有的情况，然后递归的先上进行修复，直到root为止，至此删除结束


具体代码部分参考我的GitHub  ID：yfismine

                                                   By: Y F
                                                   2019.8.16
